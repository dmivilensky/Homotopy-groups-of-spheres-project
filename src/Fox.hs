{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

-- |
-- Module      : Fox
-- Description : Fox calculus over the free group: sparse Z[F], derivatives, parsing, evaluation, and soft heuristics
-- Copyright   : (c) 2025
-- License     : BSD-3-Clause
-- Maintainer  : you@example.com
-- Stability   : experimental
-- Portability : portable
--
-- Text overview:
--
-- * Core types:
--     - 'Atom'  — a generator with (possibly negative) integer exponent.
--     - 'WordF' — a reduced free-group word (list of atoms with no consecutive equal names, nonzero exponents).
--     - 'ZF'    — sparse group-ring Z[F] as a map from reduced words to Integer coefficients.
-- * Parsing/printing: 'parseWord', 'renderWord', tokens like @"x1"@, @"a^-2"@, separated by spaces.
-- * Group operations: 'wOne', 'wInv', 'wMul', 'wPow', 'normalize', 'explodeUnits' (to ±1 steps).
-- * Group-ring ops: 'zfZero', 'zfAdd', 'zfScale', 'leftMul', 'rightMul'.
-- * Fox derivatives: 'foxD' for a single generator, 'foxAll' for a list of generators.
-- * Evaluation homomorphisms:
--     - Typeclass 'GroupLike' with 'gOne', 'gMul', 'gInv' (fits Hall-style targets).
--     - 'evalWord' folds a 'WordF' under φ :: name -> target.
--     - 'pushForward' sends Z[F] to Z[G] by mapping basis words with φ and summing equal images.
-- * Norms/metrics: 'l1Norm' (sum of |coeff|), 'supportSize', and 'pAdicMaxNorm' (needs 'vpZ' below).
-- * Heuristics for normal-closure probing: 'softMembershipScore' — greedy distance of ∂w to the
--   left-ideal generated by {∂s : s ∈ S}, after push-forward under a chosen evaluation φ (works as a soft metric).
-- * Tests: 'runFoxTests' with simple 'assert' checks; 'main' calls it.
--
module Fox
  ( WordF, Atom(..)
  , wOne, wMul, wInv, wPow, normalize, letter
  , ZF, foxD, jacobianZ
  , GroupLike(..)
  , evalWord, pushForward
  , l1Norm, pAdicMaxNorm, softMembershipScore
  , runFoxTests
  ) where

import           Control.Exception       (assert)
import           Data.Char               (isAlphaNum)
import           Data.List               (foldl', intercalate)
import           Data.Map.Strict         (Map)
import qualified Data.Map.Strict as M
import           Data.Maybe              (fromMaybe)
import           Data.Text               (Text)
import qualified Data.Text as T

--------------------------------------------------------------------------------
-- Minimal p-adic helper (vpZ) to avoid extra deps
--------------------------------------------------------------------------------

vpZ :: Integer -> Integer -> Int
vpZ _ 0 = maxBound `div` 4
vpZ p n
  | p < 2     = error "vpZ: p must be >= 2"
  | otherwise = go 0 (abs n)
  where
    go k m = case m `quotRem` p of
               (q,0) -> go (k+1) q
               _     -> k

--------------------------------------------------------------------------------
-- Core data types
--------------------------------------------------------------------------------

-- | A generator with an integer exponent (can be negative).
data Atom = Atom { aName :: Text, aExp :: !Int }
  deriving (Eq, Ord, Show)

-- | A reduced free-group word: consecutive atoms have different names,
-- and each exponent is non-zero.
newtype WordF = WordF { unW :: [Atom] }
  deriving (Eq, Ord)

instance Show WordF where
  show = T.unpack . renderWord

-- | Sparse Z[F] as a map from reduced words to integer coefficients.
type ZF = Map WordF Integer

--------------------------------------------------------------------------------
-- Parsing & rendering
--------------------------------------------------------------------------------

-- | Render a word as @"x y^-2 z"@ (space-separated).
renderWord :: WordF -> Text
renderWord (WordF xs) = T.intercalate " " (map showAtom xs)
  where
    showAtom (Atom n e)
      | e == 1   = n
      | otherwise = n <> "^" <> T.pack (show e)

-- | Parse a space-separated word; tokens are like @"x"@, @"x^-1"@, @"a^3"@.
-- Empty input parses as the identity.
parseWord :: Text -> Either String WordF
parseWord t
  | T.all isSepOrSpace t = Right wOne
  | otherwise = normalize . WordF <$> mapM parseTok toks
  where
    toks = filter (not . T.null) (T.split isSepOrSpace t)
    isSepOrSpace c = c == ' ' || c == '\t' || c == '\n'
    parseTok s =
      let (name, rest) = T.breakOn "^" s
      in if T.null name || not (T.all isAlphaNum name)
           then Left ("Invalid generator token: " <> T.unpack s)
           else
             if T.null rest
               then Right (Atom name 1)
               else
                 case (reads (T.unpack (T.drop 1 rest)) :: [(Int, String)]) of
                   [(e, "")] | e /= 0 -> Right (Atom name e)
                   _ -> Left ("Invalid exponent in token: " <> T.unpack s)

--------------------------------------------------------------------------------
-- Word operations
--------------------------------------------------------------------------------

-- | Identity word.
wOne :: WordF
wOne = WordF []

-- | Normalize (reduce) a word: merge consecutive same-name atoms, drop zeros.
normalize :: WordF -> WordF
normalize (WordF xs) = WordF (go xs)
  where
    go [] = []
    go (Atom n e : ys) =
      case go ys of
        (Atom n' e' : zs) | n == n' ->
          let e'' = e + e'
          in if e'' == 0 then zs else Atom n e'' : zs
        zs -> Atom n e : zs

-- | Multiply words and reduce.
wMul :: WordF -> WordF -> WordF
wMul (WordF u) (WordF v) = normalize (WordF (u ++ v))

-- | Inverse of a word.
wInv :: WordF -> WordF
wInv (WordF xs) = WordF (map inv (reverse xs)) where
  inv (Atom n e) = Atom n (-e)

-- | Power (can be negative).
wPow :: WordF -> Int -> WordF
wPow w 0 = wOne
wPow w k | k < 0     = wPow (wInv w) (-k)
         | otherwise = foldl' wMul wOne (replicate k w)

-- | Explode to unit steps (±1 exponents). Useful for Fox derivative scanning.
explodeUnits :: WordF -> [Atom]
explodeUnits (WordF xs) = concatMap explode xs
  where
    explode (Atom n e)
      | e == 0    = []
      | e > 0     = replicate e (Atom n 1)
      | otherwise = replicate (-e) (Atom n (-1))

--------------------------------------------------------------------------------
-- Group-ring operations Z[F]
--------------------------------------------------------------------------------

zfZero :: ZF
zfZero = M.empty

zfSingleton :: WordF -> Integer -> ZF
zfSingleton w c | c == 0    = zfZero
                | otherwise = M.singleton (normalize w) c

-- | Addition of sparse maps (keeps zeros out).
zfAdd :: ZF -> ZF -> ZF
zfAdd a b = M.filter (/=0) (M.unionWith (+) a b)

-- | Scalar multiplication.
zfScale :: Integer -> ZF -> ZF
zfScale s = M.filter (/=0) . M.map (s *)

-- | Left-multiply a Z[F] element by a word.
leftMul :: WordF -> ZF -> ZF
leftMul w = M.fromListWith (+) . map (\(g,c) -> (w `wMul` g, c)) . M.toList

-- | Right-multiply a Z[F] element by a word.
rightMul :: ZF -> WordF -> ZF
rightMul z w = M.fromListWith (+) [ (g `wMul` w, c) | (g,c) <- M.toList z ]

--------------------------------------------------------------------------------
-- Fox derivatives
--------------------------------------------------------------------------------

-- | Fox derivative ∂_{x} of a reduced word w.r.t. a generator name 'x'.
-- We implement the standard scan:
--   For w = a1 ... an (ai are unit letters), ∂_x(w) = Σ prefix_{i-1} ∂_x(ai),
--   with ∂_x(x) = 1, ∂_x(y≠x) = 0, ∂_x(x^{-1}) = -x^{-1}.
foxD :: Text -> WordF -> ZF
foxD x w =
  let units = explodeUnits w
      go _prefix [] = zfZero
      go prefix (Atom n 1 : as)
        | n == x    = zfAdd (zfSingleton prefix 1) (go (prefix `wMul` WordF [Atom n 1]) as)
        | otherwise = go (prefix `wMul` WordF [Atom n 1]) as
      go prefix (Atom n (-1) : as)
        | n == x    = let term = prefix `wMul` WordF [Atom n (-1)]
                       in zfAdd (zfSingleton term (-1)) (go (prefix `wMul` WordF [Atom n (-1)]) as)
        | otherwise = go (prefix `wMul` WordF [Atom n (-1)]) as
      go _ (_:_)    = error "foxD: unit expansion should only contain ±1 exponents"
  in go wOne units

-- | All Fox partials for given alphabet order.
foxAll :: [Text] -> WordF -> [(Text, ZF)]
foxAll xs w = [ (x, foxD x w) | x <- xs ]

--------------------------------------------------------------------------------
-- Evaluation to a target group (for compatibility with Hall or matrix models)
--------------------------------------------------------------------------------

-- | Minimal group-like interface to evaluate words.
class (Eq a, Ord a, Show a) => GroupLike a where
  gOne :: a
  gMul :: a -> a -> a
  gInv :: a -> a

-- | Evaluate a word under a homomorphism φ: name -> target.
evalWord :: GroupLike a => (Text -> a) -> WordF -> a
evalWord phi (WordF xs) = foldl' step gOne xs
  where
    step acc (Atom n e) =
      let base = phi n
          single = if e >= 0 then base else gInv base
          times  = abs e
      in iterate (gMul single) acc !! times

-- | Push-forward a Z[F] element to Z[G] by mapping each basis word using φ
-- and summing equal images. This is useful to compute norms on the quotient.
pushForward :: (GroupLike a) => (Text -> a) -> ZF -> Map a Integer
pushForward phi z =
  let pairs = [ (evalWord phi w, c) | (w,c) <- M.toList z ]
  in M.fromListWith (+) pairs

--------------------------------------------------------------------------------
-- Norms / simple metrics
--------------------------------------------------------------------------------

-- | ℓ¹ norm on Z[F]: sum of absolute values of coefficients.
l1Norm :: ZF -> Integer
l1Norm = sum . map (abs . snd) . M.toList

-- | Number of monomials (support size).
supportSize :: ZF -> Int
supportSize = length . M.toList

-- | p-adic max-norm proxy: max over terms of p^{-v_p(c)} (as Double).
-- For 0 element, returns 0.0.
pAdicMaxNorm :: Integer -> ZF -> Double
pAdicMaxNorm p z
  | M.null z  = 0
  | otherwise =
      let mags = [ (fromIntegral p) ** fromIntegral (negate (vpZ p c)) | (_,c) <- M.toList z, c /= 0 ]
      in if null mags then 0 else maximum mags

--------------------------------------------------------------------------------
-- Soft normal-closure heuristic
--------------------------------------------------------------------------------

-- | Soft membership score:
-- Given S ⊂ F and word w, compute for each generator x the derivative z_wx = ∂_x(w),
-- and try to express it (after push-forward under φ) as an integer combination of
-- {pushForward φ (∂_x s) : s ∈ S}. We do a greedy residual cancellation per image
-- bucket. The returned score is the sum over x of remaining ℓ¹ residual.
--
-- This is a soft (non-sound) proxy — good for reward shaping.
softMembershipScore
  :: (GroupLike a)
  => (Text -> a)   -- ^ evaluation φ
  -> [Text]        -- ^ alphabet
  -> [WordF]       -- ^ S (generators of normal closure)
  -> WordF         -- ^ w
  -> Integer       -- ^ score ≥ 0 (0 means perfectly matched under the heuristic)
softMembershipScore phi alphabet sSet w =
  let basisDx  = [ (x, map (\s -> pushForward phi (foxD x s)) sSet) | x <- alphabet ]
      targetDx = [ (x, pushForward phi (foxD x w))                  | x <- alphabet ]
      scoreOne (x, tw) =
        let gens = fromMaybe [] (lookup x basisDx)
        in residualL1 tw gens
  in sum (map scoreOne targetDx)
  where
    -- Greedy residual cancellation by images' buckets.
    residualL1 :: (Ord a) => Map a Integer -> [Map a Integer] -> Integer
    residualL1 target [] = sum (map (abs . snd) (M.toList target))
    residualL1 target (g:gs) =
      let target' = reduceBy target g
      in residualL1 target' gs

    reduceBy :: (Ord a) => Map a Integer -> Map a Integer -> Map a Integer
    reduceBy target g
      | M.null g  = target
      | otherwise =
          let scaleFor bucket = case (M.lookup bucket target, M.lookup bucket g) of
                                  (Just t, Just b) | b /= 0 -> t `quot` b
                                  _ -> 0
              k = maximum (0 : [ abs (scaleFor b) | b <- M.keys g ])
              try s = M.filter (/=0) (M.unionWith (-) target (M.map (* s) g))
              t1 = try k
              t2 = try (-k)
          in if l1Map t1 <= l1Map t2 then t1 else t2

    l1Map :: Map a Integer -> Integer
    l1Map = sum . map (abs . snd) . M.toList

--------------------------------------------------------------------------------
-- TESTS
--------------------------------------------------------------------------------

assertEq :: (Eq a, Show a) => String -> a -> a -> IO ()
assertEq tag a b = do
  let _ = assert (a == b) ()
  putStrLn ("[ok] " <> tag <> ": " <> show a)

assertTrue :: String -> Bool -> IO ()
assertTrue tag p = do
  let _ = assert p ()
  putStrLn ("[ok] " <> tag)

-- A tiny concrete GroupLike instance: the free abelianization Z^n represented by name -> Int vector.
-- We'll model elements as Map Text Int (exponent sums), with componentwise add and inverse.
newtype Zab = Zab (Map Text Int) deriving (Eq, Ord, Show)
instance GroupLike Zab where
  gOne = Zab M.empty
  gMul (Zab a) (Zab b) = Zab (M.filter (/=0) (M.unionWith (+) a b))
  gInv (Zab a) = Zab (M.map negate a)

phiAb :: [Text] -> Text -> Zab
phiAb gens x =
  let v = M.fromList [ (g, if g==x then 1 else 0) | g <- gens ]
  in Zab v

-- Helper to construct words quickly
w :: [ (Text, Int) ] -> WordF
w = normalize . WordF . map (uncurry Atom)

-- helper: одна буква
letter :: String -> WordF
letter s = normalize (WordF [Atom (T.pack s) 1])

-- | Строка Фокс-Якобиана для одного релятора r относительно списка генераторов.
foxRowForRel :: [String] -> WordF -> [ZF]
foxRowForRel xs r = [ foxD (T.pack x) r | x <- xs ]
{-# INLINE foxRowForRel #-}

-- | Полный Фокс-Якобиан презентации (|R| × |X|) как элементы Z[F].
jacobian :: [String] -> [WordF] -> [[ZF]]
jacobian xs rs = map (foxRowForRel xs) (map normalize rs)
{-# INLINE jacobian #-}

-- | Аугментация ε: Z[F] → Z (сумма коэффициентов).
augment :: ZF -> Integer
augment = sum . M.elems
{-# INLINE augment #-}

-- | Целочисленный Якобиан ε∘∂: каждая запись — сумма коэффициентов соответствующего Z[F].
jacobianZ :: [String] -> [WordF] -> [[Integer]]
jacobianZ xs rs = map (map augment . foxRowForRel xs) (map normalize rs)
{-# INLINE jacobianZ #-}

comm :: WordF -> WordF -> WordF
comm u v = wMul u (wMul v (wMul (wInv u) (wInv v)))

-- Basic derivative sanity:
testFoxBasics :: IO ()
testFoxBasics = do
  let x="x"; y="y"
      w1 = w [(x,1)]
      w2 = w [(x,-1)]
      w3 = w [(x,1),(y,1),(x,-1)]
      dx1 = foxD x w1
      dx2 = foxD x w2
      dx3 = foxD x w3
  -- ∂_x(x) = 1
  assertEq "d_x x has one term" 1 (supportSize dx1)
  assertEq "d_x x coefficient is 1 at 1" (fromMaybe 0 (M.lookup wOne dx1)) 1
  -- ∂_x(x^{-1}) = -x^{-1}
  assertEq "d_x x^{-1} has one term" 1 (supportSize dx2)
  assertEq "d_x x^{-1} coeff at x^{-1} is -1" (fromMaybe 0 (M.lookup (wInv w1) dx2)) (-1)
  -- ∂_x(x y x^{-1}) = 1 + x y * (-x^{-1}) = 1 - x y x^{-1}
  assertEq "d_x(x y x^{-1}) terms=2" 2 (supportSize dx3)
  let coeff1   = fromMaybe 0 (M.lookup wOne dx3)
      coeffNeg = fromMaybe 0 (M.lookup (w [(x,1),(y,1),(x,-1)]) dx3)
  assertEq "coeff at 1 is 1" 1 coeff1
  assertEq "coeff at x y x^{-1} is -1" (-1) coeffNeg

-- Evaluation & push-forward:
testEvalPush :: IO ()
testEvalPush = do
  let gens = ["x","y"]
      x="x"; y="y"
      wA = w [(x,2),(y,-1)]
      dz = foxD x wA
      phi = phiAb gens
      pushed = pushForward phi dz
      s = M.size pushed
  assertTrue "pushForward size ≤ 2" (s <= 2)
  -- evalWord should match manual fold
  let e1 = evalWord phi wA
      e2 = foldl' gMul gOne [phi "x", phi "x", gInv (phi "y")]
  assertEq "evalWord matches manual fold" e1 e2
  let dzL1 = l1Norm dz
  assertTrue "l1Norm(d) >= 1" (dzL1 >= 1)

-- Soft membership: S = {x y x^{-1} y^{-1}} (commutator) should help reduce derivative of its powers.
testSoftMembership :: IO ()
testSoftMembership = do
  let gens = ["x","y"]
      x="x"; y="y"
      comm = w [(x,1),(y,1),(x,-1),(y,-1)]
      wCandidate = wPow comm 3
      sc = softMembershipScore (phiAb gens) gens [comm] wCandidate
  assertTrue "softMembershipScore ≥ 0" (sc >= 0)

-- p-adic max-norm sanity
testPadicNorm :: IO ()
testPadicNorm = do
  let x="x"; w1 = w [(x,1)]
      d = foxD x w1                     -- {1 ↦ 1}
      n2 = pAdicMaxNorm 2 d             -- 2^{-v2(1)} = 1
  assertEq "pAdicMaxNorm 2 of 1 is 1" 1.0 n2

runFoxTests :: IO ()
runFoxTests = do
  putStrLn "Running Fox test suite..."
  testFoxBasics
  testEvalPush
  testSoftMembership
  testPadicNorm
  putStrLn "All Fox tests finished."
  let a = letter "a"
      b = letter "b"
      x = letter "x"

      relTorus = normalize (comm a b)
      relCyc q = normalize (wPow x q)
      relPos   = normalize (wMul (wPow a 3) (wPow b 2))
      relZero  = normalize (wMul (wPow a 2) (wInv (wPow a 2)))

  ok1 <- assertEq "torus jacobianZ [[0,0]]"
          (jacobianZ ["a","b"] [relTorus])
          [[0,0]]

  ok2 <- assertEq "cyclic q=5 jacobianZ [[5]]"
          (jacobianZ ["x"] [relCyc 5])
          [[5]]

  ok3 <- assertEq "a^3 b^2 -> [3,2]"
          (jacobianZ ["a","b"] [relPos])
          [[3,2]]

  ok4 <- assertEq "a^2 a^{-2} -> [0]"
          (jacobianZ ["a"] [relZero])
          [[0]]

  -- два релятора одновременно
  let rels = [relTorus, relCyc 7]
  ok5 <- assertEq "two relations -> [[0,0],[7,0]] (gens [a,b])"
          (jacobianZ ["a","b"] rels)
          [[0,0],[7,0]]

  putStrLn "Fox tests: matrix checks finished."
